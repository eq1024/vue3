# Monorepo 项目说明

本项目已从单一 Vue3 应用改造为基于 pnpm 和 Turborepo 的 Monorepo 结构，旨在支持多应用、多共享库的开发模式。

## 核心技术栈

*   **包管理器**: [pnpm](https://pnpm.io/) - 利用其高效的依赖管理和对 Monorepo 的原生支持。
*   **构建工具**: [Turborepo](https://turbo.build/) - 用于优化和加速 Monorepo 中的构建、测试和开发流程。

## 项目结构

```
.
├── apps/
│   └── web/         # 现有的 Vue3 应用
├── packages/
│   ├── ui/          # (未来) 共享组件库
│   └── utils/       # (未来) 共享工具函数
├── package.json     # 根 package.json，定义工作区和顶层脚本
├── pnpm-workspace.yaml # pnpm 工作区配置文件
└── turbo.json       # Turborepo 任务流配置文件
```

*   `apps`: 存放各个独立的应用（例如网站、后台管理系统等）。
*   `packages`: 存放可被多个 `apps` 共享的代码库（例如公共组件、工具函数、配置等）。

---

## pnpm 依赖管理核心概念 (FAQ)

这里总结了关于本项目依赖管理方式的一些常见问题。

### Q1: 为什么根目录和子项目里都有 `node_modules`？依赖是重复的吗？

**答：不是重复的，这是一种高效的链接机制。**

*   **中央仓库**: 所有依赖的真实文件，只在根目录的 `node_modules/.pnpm` 文件夹中存在一份。
*   **符号链接**: 您在根目录或子项目 `node_modules` 中看到的包，绝大部分都是指向 `.pnpm` 中央仓库的“快捷方式”（符号链接），它们几乎不占用磁盘空间。

这种设计既保证了依赖的全局共享，又节省了磁盘空间。

### Q2: 既然依赖都集中在根目录的 `.pnpm` 仓库，为什么每个子项目（如 `apps/web`）的 `node_modules` 还要有自己的内容？

**答：为了服务于 Node.js 的模块解析规则，并保证项目独立性。**

当您在代码中 `import` 一个包时，Node.js 会在当前项目的 `node_modules` 中寻找它。子项目 `node_modules` 里的链接就是为了给 Node.js “指路”，告诉它去哪里找到真正的包文件。

同时，`pnpm` 只会把您在子项目 `package.json` 中明确声明的依赖链接过来，这保证了项目的纯净和隔离性，避免了“幽灵依赖”问题。

### Q3: 为什么有些依赖（如 `@vue`）只出现在子项目里，而没有被“提升”到根目录？

**答：pnpm 默认执行最严格的隔离策略：“非必要，不提升”。**

*   一个依赖，只会被链接到明确需要它的项目中。
*   由于目前只有 `apps/web` 需要 `@vue`，所以 `pnpm` 认为没有必要将其链接到根目录，这是最干净、最准确的做法。
*   只有当未来多个项目需要**完全相同版本**的某个包时，`pnpm` 才**可能**为了优化而将其提升到根目录。

### Q4: 根目录 `node_modules` 里的那些依赖是做什么用的？

**答：主要用于服务在整个项目根目录下运行的开发工具。**

我们在根 `package.json` 的 `devDependencies` 中安装了 `turbo` 等工具。这些工具需要管理整个 Monorepo。为了让命令行在根目录能找到它们，`pnpm` 必须将这些工具的链接放在根 `node_modules` 中。

**简单总结 `node_modules` 的职责分工：**

*   **子项目的 `node_modules`**：服务于子项目的**业务代码**。
*   **根目录的 `node_modules`**：服务于管理整个项目的**开发工具**。

### Q5: 什么是 `@scope/package`？

**答：这是一种 npm 包的官方命名方式，也叫“命名空间包”。**

它的格式是 `@组织名/包名`，例如 `@vue/reactivity`。这主要用于：
1.  **避免重名**：为您的包创建独一无二的名称。
2.  **组织归类**：大型项目（如 Vue, Angular）用它来发布和管理自己的官方包系列。

---

## 常用命令

*   `pnpm install`: 在根目录执行，安装所有工作区的依赖。
*   `pnpm dev`: 启动所有应用的开发模式。
*   `pnpm build`: 构建所有应用和包。